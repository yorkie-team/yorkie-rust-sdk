use std::str;
use std::cmp;
use hex::{FromHex, FromHexError};

const ACTOR_ID_SIZE: usize = 12;

/// ActorID is bytes represented by the hexadecimal string.
/// It should be generated by unique value.
#[derive(Debug, PartialEq)]
pub struct ActorID {
    bytes: [u8; ACTOR_ID_SIZE],
}

impl ActorID {
    pub fn new(bytes: [u8; ACTOR_ID_SIZE]) -> ActorID {
        ActorID{bytes}
    }

    /// from_hex returns the ActorID represented by the hexadecimal string str.
    pub fn from_hex(hex_str: &str) -> Result<ActorID, FromHexError> {
        if hex_str == "" {
            return Err(FromHexError::InvalidStringLength);
        }

        let bytes = <[u8; 12]>::from_hex(hex_str)?;

        Ok(ActorID{bytes})
    }

    /// as_str returns the hexadecimal encoding of ActorID.
    pub fn as_str(&self) -> Result<&str, str::Utf8Error> {
        str::from_utf8(&self.bytes)
    }

    pub fn bytes(&self) -> &[u8; ACTOR_ID_SIZE] {
        &self.bytes
    }

    /// compare returns an integer comparing two ActorID lexicographically.
    /// The result will be 0 if id==other, -1 if id < other, and +1 if id > other.
    /// If the receiver or argument is nil, it would panic at runtime.
    pub fn compare(&self, other: &ActorID) -> cmp::Ordering {
        self.bytes.iter()
            .zip(other.bytes())
            .map(|(x, y)| x.cmp(y))
            .find(|&ord| ord != cmp::Ordering::Equal)
            .unwrap_or(
                self.bytes
                    .len()
                    .cmp(&other.bytes().len())
            )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn from_hex() {
        match ActorID::from_hex("") {
            Ok(_) => assert!(false),
            Err(e) => assert_eq!(FromHexError::InvalidStringLength, e),
        }

        match ActorID::from_hex("0123456789abcdef01234567") {
            Ok(_) => {},
            Err(_) => assert!(false),
        }
    }

    #[test]
    fn compare() {
        let before_actor_id = match ActorID::from_hex("0000000000abcdef01234567") {
            Ok(actor_id) => actor_id,
            Err(_) => {
                assert!(false);
                return;
            },
        };
        let after_actor_id  = match ActorID::from_hex("0123456789abcdef01234567") {
            Ok(actor_id) => actor_id,
            Err(_) => {
                assert!(false);
                return;
            },
        };

        assert_eq!(cmp::Ordering::Less, before_actor_id.compare(&after_actor_id));
        assert_eq!(cmp::Ordering::Greater, after_actor_id.compare(&before_actor_id));
        assert_eq!(cmp::Ordering::Equal, before_actor_id.compare(&before_actor_id));
    }
}